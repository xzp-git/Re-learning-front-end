
## 回顾
通过上一篇文章的介绍，我们已经完成了基出版本的promise，如下
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'

class Promise{
  constructor(executor){

    this.state = PENDING
    this.value = undefined
    this.reason = undefined
    //存放onFulfilled
    this.onResolvedCallbacks = []
    //存放onRejected
    this.onRejectedCallbacks = []
    const resolve = (value) => {
      if (this.state === PENDING) {
        this.value = value
        this.state = FULFILLED
        //promise实例状态改变后调用暂存的onFulfilled
        this.onResolvedCallbacks.forEach(fn => fn())
      }
    }

    const reject = (reason) => {
      if (this.state === PENDING) {
        this.reason = reason
        this.state = REJECTED
        //promise实例状态改变后调用的onRejected
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    try {
      //executor函数执行过程中出错，将会导致promsie失败
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }
  then(onFulfilled, onRejected){
    if (this.state === FULFILLED) {
      onFulfilled(this.value)
    }

    if (this.state === REJECTED) {
      onRejected(this.reason)
    }

    if (this.state === PENDING) {
      //如果此时promise实例的状态还未确定，我们需要将onFulfilled与onRejected存起来，等到promise实例状态改变后再去调用
      this.onResolvedCallbacks.push(() => {
        onFulfilled(this.value)
      })
      this.onRejectedCallbacks.push(() => {
        onRejected(this.reason)
      })
    }

  }
}
```
## 回调地狱
在实现`Promise`的`then`链调用机制之前我们要先来了解一下回调地狱，以及用`Promise`如何去解决回调地狱.

- 有两个文本文件`age.txt`和`name.txt`。

- 我需要读取到`age.txt`中的路径再用这个路径去读取`name.txt`的内容,代码如下。
  ```js
  const fs = require('fs') //导入node中的文件模块
  fs.readFile('./age.txt', 'utf8', function(err, data){
    if(err) throw new Error(err)
    fs.readFile(data,'utf8',function (err,data) {
        if(err) throw new Error(err)
        console.log(data)
    })
  })
  ```
- 假如有多个文件这样嵌套呢，那我们的代码就会变成这样，也就是我们所说的回调地狱。
  ```js
  fs.readFile('./age.txt', 'utf8', function(err, data){
    if(err) throw new Error(err)
    fs.readFile(data,'utf8',function (err,data) {
        if(err) throw new Error(err)
        fs.readFile(data,'utf8',function (err,data) {
            if(err) throw new Error(err)
            fs.readFile(data,'utf8',function (err,data) {
                if(err) throw new Error(err)
                fs.readFile(data,'utf8',function (err,data) {
                  if(err) throw new Error(err)
                  console.log(data)
              })
            })
        })
    })
  })
  ```
- 那么`Promise`作为一种异步编程的解决方案，它是如何解决回调地狱这种情况的呢，我们来看代码。
  - 首先我们将`readFile`的方法封装成`promise`
  ```js
  const readFile = (filePath) => {
      return new Promise((resolve,reject)=>{
           fs.readFile(filePath,'utf8',function (err,data) {
               if(err) {// 失败了调用reject
                   return reject(err);
               } 
               resolve(data); // 成功调用resolve
           })
      })
  }
  ```
  - 用我们封装后的`readFile`再去读取`age.txt`,`name.txt`的内容，编写代码就很友好了。
  ```js
  readFile('./age.txt').then(data => {
    return readFile(data)
  }).then(data => {
    console.log(data)
  },reason => {
    console.log(reason)
  })
  ```







11.05



## 回顾
我们已经完成了基出版本的promise，如下
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'

class Promise{
  constructor(executor){

    this.state = PENDING
    this.value = undefined
    this.reason = undefined
    //存放onFulfilled
    this.onResolvedCallbacks = []
    //存放onRejected
    this.onRejectedCallbacks = []
    const resolve = (value) => {
      if (this.state === PENDING) {
        this.value = value
        this.state = FULFILLED
        //promise实例状态改变后调用暂存的onFulfilled
        this.onResolvedCallbacks.forEach(fn => fn())
      }
    }

    const reject = (reason) => {
      if (this.state === PENDING) {
        this.reason = reason
        this.state = REJECTED
        //promise实例状态改变后调用的onRejected
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    try {
      //executor函数执行过程中出错，将会导致promsie失败
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }
  then(onFulfilled, onRejected){
    if (this.state === FULFILLED) {
      onFulfilled(this.value)
    }

    if (this.state === REJECTED) {
      onRejected(this.reason)
    }

    if (this.state === PENDING) {
      //如果此时promise实例的状态还未确定，我们需要将onFulfilled与onRejected存起来，等到promise实例状态改变后再去调用
      this.onResolvedCallbacks.push(() => {
        onFulfilled(this.value)
      })
      this.onRejectedCallbacks.push(() => {
        onRejected(this.reason)
      })
    }

  }
}
```
## `Promise`的`then`链调用机制
- 通过上一篇回调地狱的介绍我们可以发现，`promise`的`then`链机制，可以让我们用同步代码的编写方式，去编写我们的异步代码，`promise`的`then`链机制也是`promise`实现的最核心的地方，接下来我们将根据`Peomise A+`来继续实现我们的`Peomise`
### 返回普通值
- 1. `promise`实例的`then`方法有两个参数，一个是成功后执行的回调（`onFulfilled`）一个是失败后执行的回调(`onRejected`)，如果`then`的回调（成功的回调或者失败的回调）返回一个普通值（不是`Promise`，也不是抛出错误），则会将结果传递到下一次`then`的成功回调中。
- 2. 因为`then`方法是链式调用的，因此`then`方法每次返回的都是一个`Promise`实例。
- 3. 在执行`onFulfilled`与`onRejected`的时候如果执行过程出现异常，那么会把这个异常抛出到下一次`then`的失败回调中去。
```js
then(onFulfilled, onRejected){

  let promise = new Promsie((resolve, reject) => {
      
      switch(this.state){
        case FULFILLED:
            try{
              let x = onFulfilled(this.value)
              resolve(x)
            } catch(e){
              reject(e)
            }   
            break
        case REJECTED:
            try{
              let x = onRejected(this.reason)
              resolve(x)
            } catch(e){
              reject(e)
            }   
            break
        default:
          this.onResolvedCallbacks.push(() => {
            try{
              let x = onFulfilled(this.value)
              resolve(x)
            } catch(e){
              reject(e)
            }
          }})
          this.onRejectedCallbacks.push(() => {
            try{
              let x = onRejected(this.reason)
              resolve(x)
            } catch(e){
              reject(e)
            }
          }})
      }
    }
  })
  return promise
} 
```
- 至此我们的`then`方法已经算初步完成了，我们可以初步测试一下
  
  ```js
  let Promise = require('./promise/1.promise.js')
  
  let p = new Promise((resolve,reject) => {
      resolve('成功')
  })
  
  p.then(value => {
    console.log('value',value);
    return 10000000000000
  },reason => {
    console.log('reason',reason);
  }).then(value => {
    console.log('value',value);
  },reason => {
    console.log('reason',reason);
  })
  ```
  11-05-01.png







  11-06


## 回顾
经过上次的介绍我们的`then`方法已经有一个初步的样子了，我们的promise变成了这样：
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'

class Promise{
  constructor(executor){

    this.state = PENDING
    this.value = undefined
    this.reason = undefined
    //存放onFulfilled
    this.onResolvedCallbacks = []
    //存放onRejected
    this.onRejectedCallbacks = []
    const resolve = (value) => {
      if (this.state === PENDING) {
        this.value = value
        this.state = FULFILLED
        //promise实例状态改变后调用暂存的onFulfilled
        this.onResolvedCallbacks.forEach(fn => fn())
      }
    }

    const reject = (reason) => {
      if (this.state === PENDING) {
        this.reason = reason
        this.state = REJECTED
        //promise实例状态改变后调用的onRejected
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    try {
      //executor函数执行过程中出错，将会导致promsie失败
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }
  then(onFulfilled, onRejected){

    let promise = new Promsie((resolve, reject) => {
        
        switch(this.state){
          case FULFILLED:
              try{
                let x = onFulfilled(this.value)
                resolve(x)
              } catch(e){
                reject(e)
              }   
              break
          case REJECTED:
              try{
                let x = onRejected(this.reason)
                resolve(x)
              } catch(e){
                reject(e)
              }   
              break
          default:
            this.onResolvedCallbacks.push(() => {
              try{
                let x = onFulfilled(this.value)
                resolve(x)
              } catch(e){
                reject(e)
              }
            }})
            this.onRejectedCallbacks.push(() => {
              try{
                let x = onRejected(this.reason)
                resolve(x)
              } catch(e){
                reject(e)
              }
            }})
        }
      }
    })
    return promise
  }
}
```
## `then`方法返回的是`Promsie`
- 如果调用`Promise`实例的`then`方法返回的是一个`Promise`,那么我们需要判断这个`Promise`的状态.
  - 如果`Promise`是成功的，就将成功的结果，传递到`then`方法返回的`Peomise`的成功回调当中；
  - 如果`Promise`是失败的，就将失败的原因，传递到`then`方法返回的`Peomise`的失败回调当中。
- 那么我们的`then`方法，就不能简单的直接将其回调的返回值，传递到这个`then`方法要返回的`Promise`中了.
- 这里我们通过一个方法来解析`then`方法回调的返回值，我们称这个方法为`resolvePromise`, 这个方法不是`Promise`这个类上的方法.
- 对于resolvePromsie，这个方法的作用就是解析`then`方法中回调函数的返回值，根据返回值是什么，来改变`then`方法中将要返回的`Promise`的状态.
- 因此我们需要四个参数分别是，`then`方法要返回的`promsie`、`then`方法中回调函数的返回值`x`、将要返回的`promise`的`resolve`函数与`reject`函数。
- 相应的then方法也要进行改造。
```js


then(onFulfilled, onRejected){

    let promise = new Promsie((resolve, reject) => {
        
        switch(this.state){
          case FULFILLED:
              try{
                let x = onFulfilled(this.value)
                resolvePromise(promise, x, resolve, reject)
              } catch(e){
                reject(e)
              }   
              break
          case REJECTED:
              try{
                let x = onRejected(this.reason)
                resolvePromise(promise, x, resolve, reject)
              } catch(e){
                reject(e)
              }   
              break
          default:
            this.onResolvedCallbacks.push(() => {
              try{
                let x = onFulfilled(this.value)
                resolvePromise(promise, x, resolve, reject)
              } catch(e){
                reject(e)
              }
            }})
            this.onRejectedCallbacks.push(() => {
              try{
                let x = onRejected(this.reason)
                resolvePromise(promise, x, resolve, reject)
              } catch(e){
                reject(e)
              }
            }})
        }
      }
    })
    return promise
  }
```
## 为什么then方法中的回调（onFulfilled、onRejected）是微任务？








11-07 

## 回顾
经过上一篇文章的介绍我们的promise现在已经长这样了
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
const resolvePromise = resolvePromise(promise, x, resolve, reject) => {

}
class Promise{
  constructor(executor){

    this.state = PENDING
    this.value = undefined
    this.reason = undefined
    //存放onFulfilled
    this.onResolvedCallbacks = []
    //存放onRejected
    this.onRejectedCallbacks = []
    const resolve = (value) => {
      if (this.state === PENDING) {
        this.value = value
        this.state = FULFILLED
        //promise实例状态改变后调用暂存的onFulfilled
        this.onResolvedCallbacks.forEach(fn => fn())
      }
    }

    const reject = (reason) => {
      if (this.state === PENDING) {
        this.reason = reason
        this.state = REJECTED
        //promise实例状态改变后调用的onRejected
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    try {
      //executor函数执行过程中出错，将会导致promsie失败
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }
  then(onFulfilled, onRejected){

    let promise = new Promsie((resolve, reject) => {
        
        switch(this.state){
          case FULFILLED:
              try{
                let x = onFulfilled(this.value)
                resolvePromise(promise, x, resolve, reject)
              } catch(e){
                reject(e)
              }   
              break
          case REJECTED:
              try{
                let x = onRejected(this.reason)
                resolvePromise(promise, x, resolve, reject)
              } catch(e){
                reject(e)
              }   
              break
          default:
            this.onResolvedCallbacks.push(() => {
              try{
                let x = onFulfilled(this.value)
                resolvePromise(promise, x, resolve, reject)
              } catch(e){
                reject(e)
              }
            }})
            this.onRejectedCallbacks.push(() => {
              try{
                let x = onRejected(this.reason)
                resolvePromise(promise, x, resolve, reject)
              } catch(e){
                reject(e)
              }
            }})
        }
      }
    })
    return promise
  }
}
```
## 为什么then方法中的回调（onFulfilled、onRejected）是微任务？

11-06-1

- 像上面图片展示的那样，当代码执行到`resolvePromise`的时候其实我们是拿不到`promise`(序号2)的，这样去访问控制台会报错。

11-07-1
这个错误的意思是说，初始化前无法访问`promise`，因为对于`promsie`(序号2)来说，此时`promsie`(序号2)还处于自身`ecexutor`函数执行的时候，还没有初始化完成，也就是说此时还不存在这个实例。那么我们后续在`resolvePromise`函数中是无法拿到`promise`(序号2)的。
- 这也是为什么then方法中的回调（onFulfilled、onRejected）是异步微任务，我们可以通过浏览器提供的`queueMicrotask`方法去创建一个异步微任务，但是着个方法的兼容性不是很好，我们也可以用`setTimeout`异步宏任务去替代它，那么我们的`then`方法改造如下：
```js
then(onFulfilled, onRejected){

    let promise = new Promsie((resolve, reject) => {
        
        switch(this.state){
          case FULFILLED:
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              }})   
              break
          case REJECTED:
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          default:
            this.onResolvedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            }})
            this.onRejectedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            }})
        }
      }
    })
    return promise
  }
```
- 经过这番改造后，我们在`resolvePromsie`函数中就可以拿到`promise`进行接下来的操作了













11-08

## 回顾
经过前几次的介绍我们的`Promise`，现在长这样
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
const resolvePromise = resolvePromise(promise, x, resolve, reject) => {

}
class Promise{
  constructor(executor){

    this.state = PENDING
    this.value = undefined
    this.reason = undefined
    //存放onFulfilled
    this.onResolvedCallbacks = []
    //存放onRejected
    this.onRejectedCallbacks = []
    const resolve = (value) => {
      if (this.state === PENDING) {
        this.value = value
        this.state = FULFILLED
        //promise实例状态改变后调用暂存的onFulfilled
        this.onResolvedCallbacks.forEach(fn => fn())
      }
    }

    const reject = (reason) => {
      if (this.state === PENDING) {
        this.reason = reason
        this.state = REJECTED
        //promise实例状态改变后调用的onRejected
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    try {
      //executor函数执行过程中出错，将会导致promsie失败
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }
  then(onFulfilled, onRejected){

    let promise = new Promsie((resolve, reject) => {
        
        switch(this.state){
          case FULFILLED:
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              }})   
              break
          case REJECTED:
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          default:
            this.onResolvedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            }})
            this.onRejectedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            }})
        }
      }
    })
    return promise
  }
}
```

## `then`方法的链式调用之`resolvePromise`方法
- `resolvePromsie`的作用，主要是为了解析`then`的回调函数的返回值，从而来确定，本次`then`方法应该返回什么状态的`Promise`。

- 1. 首先判断`x`是基础类型数据，还是引用类型，基础类型的数据直接`resolve`,即可。
- 2. 如果是引用类型的数据，尝试获取`x`上的`then`属性(`x.then`)，如果在获取属性的时候报异常则`reject`
- 3. 判断`then`是否是函数，如果是一个函数则我们认定它为`Promise`,如果不是则`resolve`
- 4. 如果`x`是一个`Promsie`，我们则调用他的`then`方法，然后在`then`方法的回调中，去调用`resolve`或者`reject`，假如调用时报错则`reject`
- 5. 由此可见假如then函数中的回调返回了`Promsie`,那么then函数的返回值的状态与回调返回的`Promsie`状态息息相关。
```js
/*
promise =>  then函数要返回的promise
x => then函数中回调函数的返回值
resolve =>  then函数要返回的promise的resolve
reject  =>  then函数要返回的promise的reject
*/
const resolvePromise = (promise, x, resolve, reject) => {

  // 1.  
  if(x !== null && /^(object|function)$/.test(typeof x)){
    let then 
    // 2. 如果是引用类型的数据，尝试获取`x`上的`then`属性(`x.then`)，如果在获取属性的时候报异常则`reject`
    try{
      then = x.then
    }catch(e){
      reject(e)
    }
    //3. 判断`then`是否是函数，如果是一个函数则我们认定它为`Promise`,如果不是则`resolve`
    if(typeof then === 'function'){
      try{
        then.call(x, (y) => {
          resolvePromise(promise, y, resolve, reject)
        },(r) => {
          reject(r)
        })
      }catch(e){
        reject(e)
      }
    }else{
      resolve(x)
    }
  }else{
    //基础类型数据直接resolve
    resolve(x)
  }
}
```
- 6.对于下面图片中序号1处再次递归调用`resolvePromise`的作用是为了防止，例如下面这段代码，返回的结果是一个多次嵌套的`Promise`，依次需要去递归解析。
11-07-1
```js
let p = new Promise((resolve,reject) => {
    resolve('成功')
})

p.then(value => {
  console.log('value',value);
  //此处then函数中返回的是一个promsie，它的值又是一个promsie
  //所以递归调用resolvePromise就是为了解决这种情况
  return new Promise((resolve,reject) => { //第一个promise
    resolve(
        //第二个promise
        new Promise((resolve,reject) => {
          resolve('成功')
        })
    )
})
},reason => {
  console.log('reason',reason);
}).then(value => {
  console.log('value',value);
},reason => {
  console.log('reason',reason);
})
```
- 执行结果
11-07-3

## 到这里我们的`Promise`长这样了
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
const resolvePromise = (promise, x, resolve, reject) => {

  // 1. 首先判断`x`是基础类型数据，还是引用类型，基础类型的数据直接`resolve`,即可。
  if(x !== null && /^(object|function)$/.test(typeof x)){
    let then 
    // 2. 如果是引用类型的数据，尝试获取`x`上的`then`属性(`x.then`)，如果在获取属性的时候报异常则`reject`
    try{
      then = x.then
    }catch(e){
      reject(e)
    }
    //3. 判断`then`是否是函数，如果是一个函数则我们认定它为`Promise`,如果不是则`resolve`
    if(typeof then === 'function'){
      try{
        then.call(x, (y) => {
          resolvePromise(promise, y, resolve, reject)
        },(r) => {
          reject(r)
        })
      }catch(e){
        reject(e)
      }
    }else{
      resolve(x)
    }
  }else{
    //基础类型数据直接resolve
    resolve(x)
  }
}
class Promise{
  constructor(executor){

    this.state = PENDING
    this.value = undefined
    this.reason = undefined
    //存放onFulfilled
    this.onResolvedCallbacks = []
    //存放onRejected
    this.onRejectedCallbacks = []
    const resolve = (value) => {
      if (this.state === PENDING) {
        this.value = value
        this.state = FULFILLED
        //promise实例状态改变后调用暂存的onFulfilled
        this.onResolvedCallbacks.forEach(fn => fn())
      }
    }

    const reject = (reason) => {
      if (this.state === PENDING) {
        this.reason = reason
        this.state = REJECTED
        //promise实例状态改变后调用的onRejected
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    try {
      //executor函数执行过程中出错，将会导致Promise失败
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }
  then(onFulfilled, onRejected){

    let promise = new Promise((resolve, reject) => {
        
        switch(this.state){
          case FULFILLED:
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          case REJECTED:
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          default:
            this.onResolvedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
            this.onRejectedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
        }
      
    })
    return promise
  }
}

module.exports=Promise
```














11-09

## 回顾
到此时我们的`Promise`实现已经接近尾声了，现在我们的Promsie长这样
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
const resolvePromise = (promise, x, resolve, reject) => {

  // 1.首先判断`x`是基础类型数据，还是引用类型，基础类型的数据直接`resolve`,即可。  
  if(x !== null && /^(object|function)$/.test(typeof x)){
    let then 
    // 2. 如果是引用类型的数据，尝试获取`x`上的`then`属性(`x.then`)，如果在获取属性的时候报异常则`reject`
    try{
      then = x.then
    }catch(e){
      reject(e)
    }
    //3. 判断`then`是否是函数，如果是一个函数则我们认定它为`Promise`,如果不是则`resolve`
    if(typeof then === 'function'){
      try{
        then.call(x, (y) => {
          resolvePromise(promise, y, resolve, reject)
        },(r) => {
          reject(r)
        })
      }catch(e){
        reject(e)
      }
    }else{
      resolve(x)
    }
  }else{
    //基础类型数据直接resolve
    resolve(x)
  }
}
class Promise{
  constructor(executor){

    this.state = PENDING
    this.value = undefined
    this.reason = undefined
    //存放onFulfilled
    this.onResolvedCallbacks = []
    //存放onRejected
    this.onRejectedCallbacks = []
    const resolve = (value) => {
      if (this.state === PENDING) {
        this.value = value
        this.state = FULFILLED
        //promise实例状态改变后调用暂存的onFulfilled
        this.onResolvedCallbacks.forEach(fn => fn())
      }
    }

    const reject = (reason) => {
      if (this.state === PENDING) {
        this.reason = reason
        this.state = REJECTED
        //promise实例状态改变后调用的onRejected
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    try {
      //executor函数执行过程中出错，将会导致Promise失败
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }
  then(onFulfilled, onRejected){

    let promise = new Promise((resolve, reject) => {
        
        switch(this.state){
          case FULFILLED:
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          case REJECTED:
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          default:
            this.onResolvedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
            this.onRejectedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
        }
    })
    return promise
  }
}
```
## 关于判断是否是Promise的解释
11-09-1
- 不知道大家有没有疑问，这里判断`Promise`的方式是，一个对象或者函数并且有一个`then`属性，这个`then`属性也是一个函数，那我们就认为是`Promise`。
- 那么为什么不用`instanceof`呢？
这里其实`Promise A+`替我们想到了，就是说我们是实现的`Promise`和别人实现的`Promise`是可以混合共用的，因此我们不能通过`instanceof`去单一的判断他是否属于某个类的实例。
- 例如下面这个场景(只是为了说明原因我写的是伪代码)
```js
let Mypromise = require('xxApromise')
let Bpromise = require('xxBpromise')
let p = new Mypromise((resolve,reject) => {
    resolve('我们的Promise')
}).then(res => {
  return new Bpromise(resolve => {
    resolve('别人的Promise')
  })
}).then(res => {
  consle.log(res)
}, reason => {

})
```
- 当我们两种`Promise`混用的时候，例如这里，`Mypromise`是我们自己实现的，`Bpromise`是别人实现的。
- 我们在`then`里返回了别人的`Bpromise`，回想我们`Promise`的实现过程，这里会由`resolvePromise`去处理别人的`Bpromise`的实例，那我们通过`instanceof`，去判断是不是`Promise`，就不是很通用了。
- 因此我们采用一种通用的方法，是对象或者函数，有一个`then`属性是函数，我们就说他是`Promise`，当然这种方式有缺点，但是`Promise A+`是这么规定的。
- 因为可以混用，所以`Promise A+`里又规定，我们需要加一个变量去限制一下，在如下代码的地方，我用算是比较显眼的注释标识出来了。
```js
const resolvePromise = (promise, x, resolve, reject) => {

  // 1.首先判断`x`是基础类型数据，还是引用类型，基础类型的数据直接`resolve`,即可。  
  if(x !== null && /^(object|function)$/.test(typeof x)){
    let then 
    // 2. 如果是引用类型的数据，尝试获取`x`上的`then`属性(`x.then`)，如果在获取属性的时候报异常则`reject`
    try{
      then = x.then
    }catch(e){
      reject(e)
    }
    //3. 判断`then`是否是函数，如果是一个函数则我们认定它为`Promise`,如果不是则`resolve`
    if(typeof then === 'function'){
      let called = false //**************************************这里加了变量*************************//////
      try{
        then.call(x, (y) => {
          if(called) return //**************************************这里加了变量*************************//////
          called = true
          resolvePromise(promise, y, resolve, reject)
        },(r) => {
          if(called) return//**************************************这里加了变量*************************//////
          reject(r)
        })
      }catch(e){
        if(called) return//**************************************这里加了变量*************************//////
        reject(e)
      }
    }else{
      resolve(x)
    }
  }else{
    //基础类型数据直接resolve
    resolve(x)
  }
}
```

- 那么这个变量是用来干啥的呢？
- 其实就是为了在混用的时候(例如下面的代码)，防止别人写的`BPromsie`，实现不规范，在调用了resolve, 再去调用reject 还起作用，因此我们这里要判断，我们在`resolvePromise`中
增加的变量就是这个作用，调用了`then`中的回调，另一个就被限制了不能再次被调用。
```js
let Mypromise = require('xxApromise')
let Bpromise = require('xxBpromise')
let p = new Mypromise((resolve,reject) => {
    resolve('我们的Promise')
}).then(res => {
  return new Bpromise(resolve => {
    resolve('别人的Promise')
  })
}).then(res => {
  consle.log(res)
}, reason => {

})
```



11-10

## 回顾
经过前几篇文章的介绍，现在我们的`Promise`已经就要接近尾声，现在我们实现的`Promsie`长这样
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
const resolvePromise = (promise, x, resolve, reject) => {

  // 1.首先判断`x`是基础类型数据，还是引用类型，基础类型的数据直接`resolve`,即可。  
  if(x !== null && /^(object|function)$/.test(typeof x)){
    let then 
    // 2. 如果是引用类型的数据，尝试获取`x`上的`then`属性(`x.then`)，如果在获取属性的时候报异常则`reject`
    try{
      then = x.then
    }catch(e){
      reject(e)
    }
    //3. 判断`then`是否是函数，如果是一个函数则我们认定它为`Promise`,如果不是则`resolve`
    if(typeof then === 'function'){
      let called = false //**************************************这里加了变量*************************//////
      try{
        then.call(x, (y) => {
          if(called) return //**************************************这里加了变量*************************//////
          called = true
          resolvePromise(promise, y, resolve, reject)
        },(r) => {
          if(called) return//**************************************这里加了变量*************************//////
          reject(r)
        })
      }catch(e){
        if(called) return//**************************************这里加了变量*************************//////
        reject(e)
      }
    }else{
      resolve(x)
    }
  }else{
    //基础类型数据直接resolve
    resolve(x)
  }
}
class Promise{
  constructor(executor){

    this.state = PENDING
    this.value = undefined
    this.reason = undefined
    //存放onFulfilled
    this.onResolvedCallbacks = []
    //存放onRejected
    this.onRejectedCallbacks = []
    const resolve = (value) => {
      if (this.state === PENDING) {
        this.value = value
        this.state = FULFILLED
        //promise实例状态改变后调用暂存的onFulfilled
        this.onResolvedCallbacks.forEach(fn => fn())
      }
    }

    const reject = (reason) => {
      if (this.state === PENDING) {
        this.reason = reason
        this.state = REJECTED
        //promise实例状态改变后调用的onRejected
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    try {
      //executor函数执行过程中出错，将会导致Promise失败
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }
  then(onFulfilled, onRejected){

    let promise = new Promise((resolve, reject) => {
        
        switch(this.state){
          case FULFILLED:
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          case REJECTED:
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          default:
            this.onResolvedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
            this.onRejectedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
        }
    })
    return promise
  }
}
```
## resolvePromise方法小瑕疵解决
- 我们来看下面这段代码，假如说，`then`回调函数中返回的`Promise`是`then`函数本身所返回的`Promsie`，就会出现问题。
- 会出现什么问题呢？
  - 按照我们代码的执行逻辑，首先`then`的回调函数返回一个`Promsie`，会由`resolvePromsie`方法去解析。
  - 就以下代码来说`pThen`是第一个`then`函数的返回值，又把`pThen`作为了`then`的成功回调的返回值，那么`resolvePromsie`方法中又会调用`pThen`的`then`方法，将`pThen`这个实例自己的`resolve`与`reject`，这样就造成了自己等待自己状态的死循环。（就类似于一个荒唐的列子，我等我自己做饭给我自己吃，我们是永远等不到的）
```js
let p = new Promise((resolve,reject) => {
  resolve('成功')
})

let pThen = then(value => {
return pThen
}).then(value => {
console.log('value',value);
},reason => {
console.log('reason',reason);
})
```
- 因此对于这个问题，我们需要改造一下`resolvePromsie`方法，做个小判断即可,代码如下
```js
const resolvePromise = (promise, x, resolve, reject) => {
  //*******************************************************判断x与promsie是否是同一个promise，防止进入死循环*********************//////*********
  if(x === promise) throw new TypeError('Chaining cycle detected for promise #<Promise>')


  // 1.首先判断`x`是基础类型数据，还是引用类型，基础类型的数据直接`resolve`,即可。  
  if(x !== null && /^(object|function)$/.test(typeof x)){
    let then 
    // 2. 如果是引用类型的数据，尝试获取`x`上的`then`属性(`x.then`)，如果在获取属性的时候报异常则`reject`
    try{
      then = x.then
    }catch(e){
      reject(e)
    }
    //3. 判断`then`是否是函数，如果是一个函数则我们认定它为`Promise`,如果不是则`resolve`
    if(typeof then === 'function'){
      let called = false 
      try{
        then.call(x, (y) => {
          if(called) return 
          called = true
          resolvePromise(promise, y, resolve, reject)
        },(r) => {
          if(called) return
          reject(r)
        })
      }catch(e){
        if(called) return
        reject(e)
      }
    }else{
      resolve(x)
    }
  }else{
    //基础类型数据直接resolve
    resolve(x)
  }
}
```






11-11

## 回顾
经过前面9篇文章的介绍，我们的`Promise`已经接近尾声了，现在它长这样
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
const resolvePromise = (promise, x, resolve, reject) => {
  //*******************************************************判断x与promsie是否是同一个promise，防止进入死循环*********************//////*********
  if(x === promise) throw new TypeError('Chaining cycle detected for promise #<Promise>')
  // 1.首先判断`x`是基础类型数据，还是引用类型，基础类型的数据直接`resolve`,即可。  
  if(x !== null && /^(object|function)$/.test(typeof x)){
    let then 
    // 2. 如果是引用类型的数据，尝试获取`x`上的`then`属性(`x.then`)，如果在获取属性的时候报异常则`reject`
    try{
      then = x.then
    }catch(e){
      reject(e)
    }
    //3. 判断`then`是否是函数，如果是一个函数则我们认定它为`Promise`,如果不是则`resolve`
    if(typeof then === 'function'){
      let called = false //**************************************这里加了变量*************************//////
      try{
        then.call(x, (y) => {
          if(called) return //**************************************这里加了变量*************************//////
          called = true
          resolvePromise(promise, y, resolve, reject)
        },(r) => {
          if(called) return//**************************************这里加了变量*************************//////
          reject(r)
        })
      }catch(e){
        if(called) return//**************************************这里加了变量*************************//////
        reject(e)
      }
    }else{
      resolve(x)
    }
  }else{
    //基础类型数据直接resolve
    resolve(x)
  }
}
class Promise{
  constructor(executor){

    this.state = PENDING
    this.value = undefined
    this.reason = undefined
    //存放onFulfilled
    this.onResolvedCallbacks = []
    //存放onRejected
    this.onRejectedCallbacks = []
    const resolve = (value) => {
      if (this.state === PENDING) {
        this.value = value
        this.state = FULFILLED
        //promise实例状态改变后调用暂存的onFulfilled
        this.onResolvedCallbacks.forEach(fn => fn())
      }
    }

    const reject = (reason) => {
      if (this.state === PENDING) {
        this.reason = reason
        this.state = REJECTED
        //promise实例状态改变后调用的onRejected
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    try {
      //executor函数执行过程中出错，将会导致Promise失败
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }
  then(onFulfilled, onRejected){

    let promise = new Promise((resolve, reject) => {
        
        switch(this.state){
          case FULFILLED:
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          case REJECTED:
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          default:
            this.onResolvedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
            this.onRejectedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
        }
    })
    return promise
  }
}
```
## `then`方法小瑕疵解决
- 有这样一种情况，我们的`then`方法，是无法满足链式调用的，例如下面这段代码，用户在调用`then`方法的时候不传值，或者传递了空，我们需要判断处理一下，让`then`函数能够继续链式调用。
```js
let p = new Promise((resolve,reject) => {
  resolve('成功')
})

p.then().then(value => {
console.log('value',value);
},reason => {
console.log('reason',reason);
})
// p.then(null, null).then(value => {
// console.log('value',value);
// },reason => {
// console.log('reason',reason);
// })
```
- `then`方法改造如下
如果用户在使用`then`方法的时候没有传递`onFulfilled`/`onRejected`，或者传递不是一个函数，那我们要给`onFulfilled`/`onRejected`赋予默认值，这样就可以链式调用了。
```js
then(onFulfilled, onRejected){
  
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v
    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err }

    let promise = new Promise((resolve, reject) => {
        
        switch(this.state){
          case FULFILLED:
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          case REJECTED:
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          default:
            this.onResolvedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
            this.onRejectedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
        }
    })
    return promise
  }
```



11 - 12

## 回顾
经过10篇文章的介绍我们的`Promsie`已经完成了，接下来我们准备通过一个第三方的npm包来测试一下我们的`Promise`是否符合`Promise A+`规范。

现在完全体的`Promise`长这样

```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
const resolvePromise = (promise, x, resolve, reject) => {
  //*******************************************************判断x与promsie是否是同一个promise，防止进入死循环*********************//////*********
  if(x === promise) throw new TypeError('Chaining cycle detected for promise #<Promise>')
  // 1.首先判断`x`是基础类型数据，还是引用类型，基础类型的数据直接`resolve`,即可。  
  if(x !== null && /^(object|function)$/.test(typeof x)){
    let then 
    // 2. 如果是引用类型的数据，尝试获取`x`上的`then`属性(`x.then`)，如果在获取属性的时候报异常则`reject`
    try{
      then = x.then
    }catch(e){
      reject(e)
    }
    //3. 判断`then`是否是函数，如果是一个函数则我们认定它为`Promise`,如果不是则`resolve`
    if(typeof then === 'function'){
      let called = false //**************************************这里加了变量*************************//////
      try{
        then.call(x, (y) => {
          if(called) return //**************************************这里加了变量*************************//////
          called = true
          resolvePromise(promise, y, resolve, reject)
        },(r) => {
          if(called) return//**************************************这里加了变量*************************//////
          reject(r)
        })
      }catch(e){
        if(called) return//**************************************这里加了变量*************************//////
        reject(e)
      }
    }else{
      resolve(x)
    }
  }else{
    //基础类型数据直接resolve
    resolve(x)
  }
}
class Promise{
  constructor(executor){

    this.state = PENDING
    this.value = undefined
    this.reason = undefined
    //存放onFulfilled
    this.onResolvedCallbacks = []
    //存放onRejected
    this.onRejectedCallbacks = []
    const resolve = (value) => {
      if (this.state === PENDING) {
        this.value = value
        this.state = FULFILLED
        //promise实例状态改变后调用暂存的onFulfilled
        this.onResolvedCallbacks.forEach(fn => fn())
      }
    }

    const reject = (reason) => {
      if (this.state === PENDING) {
        this.reason = reason
        this.state = REJECTED
        //promise实例状态改变后调用的onRejected
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    try {
      //executor函数执行过程中出错，将会导致Promise失败
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }
  then(onFulfilled, onRejected){
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v
    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err }
    let promise = new Promise((resolve, reject) => {
        
        switch(this.state){
          case FULFILLED:
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          case REJECTED:
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          default:
            this.onResolvedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
            this.onRejectedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
        }
    })
    return promise
  }
}
```
## 测试流程
- 1. `npm init --yes` 初始化`package.json`
- 2. `npm i promise-aplus-tests -D` 本地安装测试`Promise`的第三方包
- 3. 在`index.js`文件中，放入我们要测试的`Promise`，并加入以下代码.
  - 这段代码很简单，在`Promise`上扩展一个静态的方法，这个方法返回一个对象`dfd`，`dfd`上有三个属性，一个是`Promsie`实例，另外两个分别是其对应的`resolve`、`reject`。
  - 其实就是相当于调用这个方法，可以创建一个`Promise`实例，并把这个实例返回。
  ```js
  Promise.deferred = function(){
  let dfd = {}
  dfd.promise = new Promise((resolve,reject)=>{
        dfd.resolve = resolve;
        dfd.reject = reject;
    })
    return dfd;
  }
  ```
- 4. 最后导出我们的`Promsie`
  ```js
  module.exports = Promise
  
  ```
## `index.js`长这样
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
const resolvePromise = (promise, x, resolve, reject) => {
  //*******************************************************判断x与promsie是否是同一个promise，防止进入死循环*********************//////*********
  if(x === promise) throw new TypeError('Chaining cycle detected for promise #<Promise>')
  // 1.首先判断`x`是基础类型数据，还是引用类型，基础类型的数据直接`resolve`,即可。  
  if(x !== null && /^(object|function)$/.test(typeof x)){
    let then 
    // 2. 如果是引用类型的数据，尝试获取`x`上的`then`属性(`x.then`)，如果在获取属性的时候报异常则`reject`
    try{
      then = x.then
    }catch(e){
      reject(e)
    }
    //3. 判断`then`是否是函数，如果是一个函数则我们认定它为`Promise`,如果不是则`resolve`
    if(typeof then === 'function'){
      let called = false //**************************************这里加了变量*************************//////
      try{
        then.call(x, (y) => {
          if(called) return //**************************************这里加了变量*************************//////
          called = true
          resolvePromise(promise, y, resolve, reject)
        },(r) => {
          if(called) return//**************************************这里加了变量*************************//////
          reject(r)
        })
      }catch(e){
        if(called) return//**************************************这里加了变量*************************//////
        reject(e)
      }
    }else{
      resolve(x)
    }
  }else{
    //基础类型数据直接resolve
    resolve(x)
  }
}
class Promise{
  constructor(executor){

    this.state = PENDING
    this.value = undefined
    this.reason = undefined
    //存放onFulfilled
    this.onResolvedCallbacks = []
    //存放onRejected
    this.onRejectedCallbacks = []
    const resolve = (value) => {
      if (this.state === PENDING) {
        this.value = value
        this.state = FULFILLED
        //promise实例状态改变后调用暂存的onFulfilled
        this.onResolvedCallbacks.forEach(fn => fn())
      }
    }

    const reject = (reason) => {
      if (this.state === PENDING) {
        this.reason = reason
        this.state = REJECTED
        //promise实例状态改变后调用的onRejected
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    try {
      //executor函数执行过程中出错，将会导致Promise失败
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }
  then(onFulfilled, onRejected){
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v
    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err }
    let promise = new Promise((resolve, reject) => {
        
        switch(this.state){
          case FULFILLED:
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          case REJECTED:
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          default:
            this.onResolvedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
            this.onRejectedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
        }
    })
    return promise
  }
}

Promise.deferred = function(){
  let dfd = {}
  dfd.promise = new Promise((resolve,reject)=>{
      dfd.resolve = resolve;
      dfd.reject = reject;
  })
  return dfd;
}




module.exports = Promise

```
## 添加测试的执行脚本
- 在`package.json`中添加下面的脚本
```js
"scripts": {
    "test": "promises-aplus-tests index.js"
},
```
- 在终端输入`npm run test`









## 回顾 
经过前几篇文章的介绍，我们的`Promise`已经经过了，`Promise A+`规范的测试，现在我们的`Promise`,长这样
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
const resolvePromise = (promise, x, resolve, reject) => {
  //*******************************************************判断x与promsie是否是同一个promise，防止进入死循环*********************//////*********
  if(x === promise) throw new TypeError('Chaining cycle detected for promise #<Promise>')
  // 1.首先判断`x`是基础类型数据，还是引用类型，基础类型的数据直接`resolve`,即可。  
  if(x !== null && /^(object|function)$/.test(typeof x)){
    let then 
    // 2. 如果是引用类型的数据，尝试获取`x`上的`then`属性(`x.then`)，如果在获取属性的时候报异常则`reject`
    try{
      then = x.then
    }catch(e){
      reject(e)
    }
    //3. 判断`then`是否是函数，如果是一个函数则我们认定它为`Promise`,如果不是则`resolve`
    if(typeof then === 'function'){
      let called = false //**************************************这里加了变量*************************//////
      try{
        then.call(x, (y) => {
          if(called) return //**************************************这里加了变量*************************//////
          called = true
          resolvePromise(promise, y, resolve, reject)
        },(r) => {
          if(called) return//**************************************这里加了变量*************************//////
          reject(r)
        })
      }catch(e){
        if(called) return//**************************************这里加了变量*************************//////
        reject(e)
      }
    }else{
      resolve(x)
    }
  }else{
    //基础类型数据直接resolve
    resolve(x)
  }
}
class Promise{
  constructor(executor){

    this.state = PENDING
    this.value = undefined
    this.reason = undefined
    //存放onFulfilled
    this.onResolvedCallbacks = []
    //存放onRejected
    this.onRejectedCallbacks = []
    const resolve = (value) => {
      if (this.state === PENDING) {
        this.value = value
        this.state = FULFILLED
        //promise实例状态改变后调用暂存的onFulfilled
        this.onResolvedCallbacks.forEach(fn => fn())
      }
    }

    const reject = (reason) => {
      if (this.state === PENDING) {
        this.reason = reason
        this.state = REJECTED
        //promise实例状态改变后调用的onRejected
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    try {
      //executor函数执行过程中出错，将会导致Promise失败
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }
  then(onFulfilled, onRejected){
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v
    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err }
    let promise = new Promise((resolve, reject) => {
        
        switch(this.state){
          case FULFILLED:
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          case REJECTED:
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          default:
            this.onResolvedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
            this.onRejectedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
        }
    })
    return promise
  }
}
```
## `Promsie`的其他方法
我们完成了，`Promsie`的主体后，还有一些其他的方法(这些方法并不属于`Promsie A+`中规定的)，例如`catch`、`reject`、`resolve`等等，这章节主要介绍这三个方法。
## `catch`方法
`catch`方法很简单，`catch`方法是原型上的方法，它的作用主要是捕获`Promise`失败的，其实内部实现就是调用`then`方法的传入第二个参数（第一个参数传`null`），具体实现如下：
```js
catch(onRejected){
  return this.then(null, onRejected)
}
```

## `resolve`方法
`resolve`方法是静态方法，它的作用是返回一个成功的`Promsie`。

- **注意** 但是并不是说`resolve`方法返回的一定是成功，他也会返回失败的`Promise`,看下面这张图片。
假如说给`resolve`传递了一个`Promise`，那`resolve`返回的`Promise`会由嵌套的这个`Promise`，去决定。
11-15-01

`resolve`实现如下，我们还需要改动我们`Promsie`的`resolve`方法。
```js

const resolve = (value) => {
   //如果发现value是一个Promise，我们需要调用value的then方法去递归解析
  if(value instanceof Promise){
      return value.then(resolve,reject); // 递归解析
  }
  if (this.state === PENDING) {
    this.value = value
    this.state = FULFILLED
    //promise实例状态改变后调用暂存的onFulfilled
    this.onResolvedCallbacks.forEach(fn => fn())
  }
}


static rsolve(value){
  return new Promise((resolve,reject)=>{
            resolve(value);
  })
}

```
## `reject`方法
`reject`方法十分的简单，他也是静态方法，它的作用是返回一个失败的`Promise`,实现如下。
```js
static reject(reason){
    return new Promise((resolve,reject)=>{
        reject(reason);
    })
}
```
## 截至目前的`Promise`
现在我们的`Promise`长这样.
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
const resolvePromise = (promise, x, resolve, reject) => {
  //*******************************************************判断x与promsie是否是同一个promise，防止进入死循环*********************//////*********
  if(x === promise) throw new TypeError('Chaining cycle detected for promise #<Promise>')
  // 1.首先判断`x`是基础类型数据，还是引用类型，基础类型的数据直接`resolve`,即可。  
  if(x !== null && /^(object|function)$/.test(typeof x)){
    let then 
    // 2. 如果是引用类型的数据，尝试获取`x`上的`then`属性(`x.then`)，如果在获取属性的时候报异常则`reject`
    try{
      then = x.then
    }catch(e){
      reject(e)
    }
    //3. 判断`then`是否是函数，如果是一个函数则我们认定它为`Promise`,如果不是则`resolve`
    if(typeof then === 'function'){
      let called = false //**************************************这里加了变量*************************//////
      try{
        then.call(x, (y) => {
          if(called) return //**************************************这里加了变量*************************//////
          called = true
          resolvePromise(promise, y, resolve, reject)
        },(r) => {
          if(called) return//**************************************这里加了变量*************************//////
          reject(r)
        })
      }catch(e){
        if(called) return//**************************************这里加了变量*************************//////
        reject(e)
      }
    }else{
      resolve(x)
    }
  }else{
    //基础类型数据直接resolve
    resolve(x)
  }
}
class Promise{
  constructor(executor){

    this.state = PENDING
    this.value = undefined
    this.reason = undefined
    //存放onFulfilled
    this.onResolvedCallbacks = []
    //存放onRejected
    this.onRejectedCallbacks = []
    const resolve = (value) => {
       //如果发现value是一个Promise，我们需要调用value的then方法去递归解析
      if(value instanceof Promise){
          return value.then(resolve,reject); // 递归解析
      }
      if (this.state === PENDING) {
        this.value = value
        this.state = FULFILLED
        //promise实例状态改变后调用暂存的onFulfilled
        this.onResolvedCallbacks.forEach(fn => fn())
      }
    }

    const reject = (reason) => {
      if (this.state === PENDING) {
        this.reason = reason
        this.state = REJECTED
        //promise实例状态改变后调用的onRejected
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    try {
      //executor函数执行过程中出错，将会导致Promise失败
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }
  then(onFulfilled, onRejected){
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v
    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err }
    let promise = new Promise((resolve, reject) => {
        
        switch(this.state){
          case FULFILLED:
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          case REJECTED:
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          default:
            this.onResolvedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
            this.onRejectedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
        }
    })
    return promise
  }
  catch(onRejected){
    return this.then(null, onRejected)
  }
  static rsolve(value){
    return new Promise((resolve,reject)=>{
              resolve(value);
    })
  }
  static reject(reason){
      return new Promise((resolve,reject)=>{
          reject(reason);
      })
  }
}
```

11-17

## 回顾
经过上次的文章介绍，我们的Promise已经完成了，catch、reject、resolve方法，现在的Promsie已经长这样了。
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
const resolvePromise = (promise, x, resolve, reject) => {
  //*******************************************************判断x与promsie是否是同一个promise，防止进入死循环*********************//////*********
  if(x === promise) throw new TypeError('Chaining cycle detected for promise #<Promise>')
  // 1.首先判断`x`是基础类型数据，还是引用类型，基础类型的数据直接`resolve`,即可。  
  if(x !== null && /^(object|function)$/.test(typeof x)){
    let then 
    // 2. 如果是引用类型的数据，尝试获取`x`上的`then`属性(`x.then`)，如果在获取属性的时候报异常则`reject`
    try{
      then = x.then
    }catch(e){
      reject(e)
    }
    //3. 判断`then`是否是函数，如果是一个函数则我们认定它为`Promise`,如果不是则`resolve`
    if(typeof then === 'function'){
      let called = false //**************************************这里加了变量*************************//////
      try{
        then.call(x, (y) => {
          if(called) return //**************************************这里加了变量*************************//////
          called = true
          resolvePromise(promise, y, resolve, reject)
        },(r) => {
          if(called) return//**************************************这里加了变量*************************//////
          reject(r)
        })
      }catch(e){
        if(called) return//**************************************这里加了变量*************************//////
        reject(e)
      }
    }else{
      resolve(x)
    }
  }else{
    //基础类型数据直接resolve
    resolve(x)
  }
}
class Promise{
  constructor(executor){

    this.state = PENDING
    this.value = undefined
    this.reason = undefined
    //存放onFulfilled
    this.onResolvedCallbacks = []
    //存放onRejected
    this.onRejectedCallbacks = []
    const resolve = (value) => {
       //如果发现value是一个Promise，我们需要调用value的then方法去递归解析
      if(value instanceof Promise){
          return value.then(resolve,reject); // 递归解析
      }
      if (this.state === PENDING) {
        this.value = value
        this.state = FULFILLED
        //promise实例状态改变后调用暂存的onFulfilled
        this.onResolvedCallbacks.forEach(fn => fn())
      }
    }

    const reject = (reason) => {
      if (this.state === PENDING) {
        this.reason = reason
        this.state = REJECTED
        //promise实例状态改变后调用的onRejected
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    try {
      //executor函数执行过程中出错，将会导致Promise失败
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }
  then(onFulfilled, onRejected){
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v
    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err }
    let promise = new Promise((resolve, reject) => {
        
        switch(this.state){
          case FULFILLED:
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          case REJECTED:
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          default:
            this.onResolvedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
            this.onRejectedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
        }
    })
    return promise
  }
  catch(onRejected){
    return this.then(null, onRejected)
  }
  static rsolve(value){
    return new Promise((resolve,reject)=>{
              resolve(value);
    })
  }
  static reject(reason){
      return new Promise((resolve,reject)=>{
          reject(reason);
      })
  }
}
```
## 本篇文章介绍
- 本篇文章主要完成的是，`finally`方法，这个方法在面试中也是经常会问到，是怎么实现的。 `finally`方法是原型上的方法。
## 手撕`finally`方法
- `finally`方法会接受一个回调函数，不论这个`Promise`是成功还是失败都会执行这个回调函数。

- 实现原理，其实`finally`方法的内部是通过`then`方法与`Promise.resolve`来实现的。
- 原理如下
```js
finally(cb){
  return this.then(
    (y) => {
      return Promise.resolve(cb()).then(() => y)
    },
    (r) => {
      return Promise.resolve(cb()).then(() => {throw r})
    }
  )
}

```
## 解析`finally`实现原理
- 相信大家和我一样看了上边的实现，觉得脑瓜子嗡嗡的，心里一万个草泥马奔腾，写的特么什么玩意。
- 下面我将通过四个小事例来解答大家心中的疑惑，因为`finally`的实现还用到了`resolve`，为了方便我的表达，我在下面两张图片中标了一些序号方便大家根据我的思路来进行对照。

> finally实现的关键代码 

![11-17-01](D:\Desktop\11-17-01.png)



> resolve实现的关键代码

![11-17-02](D:\Desktop\11-17-02.png)

![11-17-03](D:\Desktop\11-17-04.png)

- 下面在解释事例的执行逻辑时，用到的序号都是上面两张图片中所标识的，如果不了解`resolve`的实现过程的，可以通过传送门去看一下以前的文章，专门的介绍了`resolve`的实现。

- 事例1

  ```js
  Promise.resolve('ok').finally(() => { 
      return new Promise((resolve,reject)=>{
          setTimeout(() => {
              resolve('inner ok')
          }, 1000);
      })
  }).then((data) => {
      console.log('成功', data)
  }, (err) => {
      console.log('失败', err)
  })
  ```

  - 原生Promise执行结果（浏览器控制台打印）![11-17-03](D:\Desktop\11-17-05.png)

  - 根据我们实现的代码来运行这段事例，顺序如下。

    `Promise.resolve('ok')` ---> 调用`finally` 执行`F1` 此时`y`是`ok`---> 执行`R1` --->`F3`最终返回成功的`Promsie`值是`inner ok` ---> 执行`R2` `F1` 中的 `Promise.resolve`  返回了成功的`Promise` --->执行`F5`

    此时F5返回的是`y`(ok)，也就是说整个`finally`到此执行结束返回值是一个成功的`Promise` 值是`ok` ---> 调用`then`执行成功的回调，最后打印 ‘成功 `ok`‘

- 事例2

  ```js
  Promise.resolve('ok').finally(() => {
      return new Promise((resolve,reject)=>{
          setTimeout(() => {
              reject('inner ok')
          }, 1000);
      })
  }).then((data) => {
      console.log('成功', data)
  }, (err) => {
      console.log('失败', err)
  })
  ```

  - 原生Promise执行结果（浏览器控制台打印）

    ![11-17-03](D:\Desktop\11-17-06.png)

  - 根据我们实现的代码来运行这段事例，顺序如下。

    `Promise.resolve('ok')` ---> 调用`finally` 执行`F1` 此时`y`是`ok`---> 执行`R1` --->`F3`最终返回失败的`Promsie`原因是`inner ok` ---> 执行`R3` `F1` 中的 `Promise.resolve` 返回了失败的`Promise`原因是`inner ok` ---> 此时`then`并不会执行`F5`，`then`函数会默认补充第二个失败的回调函数，所以`F1`会返回失败的`Promsie`原因是`inner ok`，也就是说整个`finally`到此执行结束返回值是一个失败的`Promsie`原因是`inner ok` ---> 调用`then`执行失败的回调，最后打印 ‘失败 `inner ok`‘

- 事例3与事例4 我就不带着大家分析了大家可以自己按照我的方式分析一下，前提是大家自己手写过`Promise`，不然的话分析起来会很吃力。

  ![11-17-03](D:\Desktop\11-17-07.png)

  ​      ![11-17-03](D:\Desktop\11-17-08.png)


11-22

## 回顾
结果一段时间的介绍，我们`Promise`的实现就到这里了,下面是我最终整理的`Promise`。
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
const resolvePromise = (promise, x, resolve, reject) => {
  //*******************************************************判断x与promsie是否是同一个promise，防止进入死循环*********************//////*********
  if(x === promise) throw new TypeError('Chaining cycle detected for promise #<Promise>')
  // 1.首先判断`x`是基础类型数据，还是引用类型，基础类型的数据直接`resolve`,即可。  
  if(x !== null && /^(object|function)$/.test(typeof x)){
    let then 
    // 2. 如果是引用类型的数据，尝试获取`x`上的`then`属性(`x.then`)，如果在获取属性的时候报异常则`reject`
    try{
      then = x.then
    }catch(e){
      reject(e)
    }
    //3. 判断`then`是否是函数，如果是一个函数则我们认定它为`Promise`,如果不是则`resolve`
    if(typeof then === 'function'){
      let called = false //**************************************这里加了变量*************************//////
      try{
        then.call(x, (y) => {
          if(called) return //**************************************这里加了变量*************************//////
          called = true
          resolvePromise(promise, y, resolve, reject)
        },(r) => {
          if(called) return//**************************************这里加了变量*************************//////
          reject(r)
        })
      }catch(e){
        if(called) return//**************************************这里加了变量*************************//////
        reject(e)
      }
    }else{
      resolve(x)
    }
  }else{
    //基础类型数据直接resolve
    resolve(x)
  }
}
class Promise{
  constructor(executor){

    this.state = PENDING
    this.value = undefined
    this.reason = undefined
    //存放onFulfilled
    this.onResolvedCallbacks = []
    //存放onRejected
    this.onRejectedCallbacks = []
    const resolve = (value) => {
       //如果发现value是一个Promise，我们需要调用value的then方法去递归解析
      if(value instanceof Promise){
          return value.then(resolve,reject); // 递归解析
      }
      if (this.state === PENDING) {
        this.value = value
        this.state = FULFILLED
        //promise实例状态改变后调用暂存的onFulfilled
        this.onResolvedCallbacks.forEach(fn => fn())
      }
    }

    const reject = (reason) => {
      if (this.state === PENDING) {
        this.reason = reason
        this.state = REJECTED
        //promise实例状态改变后调用的onRejected
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    try {
      //executor函数执行过程中出错，将会导致Promise失败
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }
  then(onFulfilled, onRejected){
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v
    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err }
    let promise = new Promise((resolve, reject) => {
        
        switch(this.state){
          case FULFILLED:
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          case REJECTED:
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })   
              break
          default:
            this.onResolvedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onFulfilled(this.value)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
            this.onRejectedCallbacks.push(() => {
              setTimeout(() => {
                try{
                  let x = onRejected(this.reason)
                  resolvePromise(promise, x, resolve, reject)
                } catch(e){
                  reject(e)
                }
              })
            })
        }
    })
    return promise
  }
  catch(onRejected){
    return this.then(null, onRejected)
  }

  finally(cb){
    return this.then(
        (y) => {
        return Promise.resolve(cb()).then(() => y)
        },
        (r) => {
        return Promise.resolve(cb()).then(() => {throw r})
        }
    )
  }  

  static rsolve(value){
    return new Promise((resolve,reject)=>{
              resolve(value);
    })
  }
  static reject(reason){
      return new Promise((resolve,reject)=>{
          reject(reason);
      })
  }

  static all (promsies){
        return new Promise((resolve, reject) => {
            const arr = []

            let count = 0
            const processResult = (i, val) => {
                arr[i] = val
                if(++times === promises.length) resolve(arr)
            }

            for(let i = 0; i < promises.length; i++){
                let val = promises[i]
                if(typeof val.then === 'function'){
                    val.then(y => processResult(i, y), reject)
                }else{
                    processResult(i, val)
                }
            }
        })
  }
  static race(promises) {
        return new Promsie((resolve, reject)=>{
            for(let i = 0; i < promise.length; i++){
                let p = promises[i]
                Promise.resolve(p).then(resolve, reject)
            }
        })
  }

}
```
## 本篇文章介绍
我们本篇文章，主要是使用`Promise.race`方法来实现调用接口超时放弃的功能，我们把他来封装成一个工具方法。
- 我们通过一个函数（`wrap`）来实现, 函数的返回值是`Promise`。
- `wrap`函数的参数`p`表示我们需要传入的`Promise`，我们在`wrap`内部声明一个`p1`的`Promsie`将`p1`的`reject`方法暴露出去，利用`Promise.race`的特点，哪个`Promise`先完成就采用那个`Promise`的结果，假如我们传入的`p`，响应的时间超过了我们的期望，那我们就可以调用`r.abort`来放弃本次结果。
```js
const wrap = (p) => {
  let abort = null

  let p1 = new Promise((resolve, reject) => {
    abort = reject
  })
  let r = Promise.race([p,p1])

  r.abort = abort
  
  return r
}
```
## 事例
通过一个小事例来更好的理解`wrap`方法。
```js
let p = new Promise((resolve,reject) => {
  setTimeout(() => {
    resolve('模拟请求结果')
  },4000)
})

let newP = wrap(p)

setTimeout(() => {
  newP.abort('超过了3s放弃')//超时就不采用成功的结果了,调用abort让promsie走失败的回调
},3000)

newP.then(data => {
  cosole.leg('成功'，data)
}, reason => {
  cosole.leg('失败'，reason)
})

```





11-25

## `generator`函数
`generator`函数的声明是在`func0tion`关键字后面加`*`来进行声明的。
```js
function* say(){
  let a = yield 'h'
  console.log(a, 'a')
  let b = yield 'ell'
  console.log(b, 'b')
}
```
### 生成器与迭代器
`generator`函数也被称作为生成器，他的返回值是一个迭代器，下面的`it`就是称之为迭代器。
```js
let it = say()
```
### `next`
我们可以通过`it`来调用`next()`，`next()` 方法返回一个包含属性 `done` 和 `value` 的对象。该方法也可以通过接受一个参数用以向生成器传值。
```js
let o1 = it.next() //{value:'h', done:false} //第一次的next不需要传递参数，传了也没有意义
let o2 = it.next('2') // {value:'ell', done:false}  第二次调用next我们传递的参数会把值赋给a  此时会打印 2 a   假如我们不传递参数 a的值就是undefined

let o3 = it.next() //{value:undefined, done:true} 
```

### `return`
`return()` 方法返回给定的值并结束生成器。
```js
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

var g = gen();

g.next();        // { value: 1, done: false }
g.return("foo"); // { value: "foo", done: true }
g.next();        // { value: undefined, done: true }
```
### `throw`
throw() 方法用来向生成器抛出异常。

下面的例子展示了一个简单的生成器并使用 throw方法向该生成器抛出一个异常，该异常通常可以通过 try...catch 块进行捕获.
```js
function* gen() {
  while(true) {
    try {
       yield 88;
    } catch(e) {
      console.log("err!");
    }
  }
}

var g = gen();
g.next(); // { value: 88, done: false }
g.throw(new Error("err")); // "err!"
```
## `generator`函数与`co`

- 我们在使用迭代器的时候需要一次一次的调用`next()`方法，这很不方便，`co`函数的作用主要是给我们自动的去调用迭代器，我们只需要把迭代器传递给它，它会自动帮我们迭代完，不需要我们手动的去一次次迭代了。

- `co`函数也有别人写好的npm包，可以去安装`npm install co`，我们主要来实现一下`co`。

```js
function co(it){
    return new Promise((resolve,reject)=>{
        // 异步迭代就采用回调函数的方式 
        function next(data){
            let { value, done } = it.next(data);
            if(done){
                return resolve(value)
            }
            Promise.resolve(value).then(next,(err)=>{
                it.throw(err);
            })
        }
        next();
    })
}
```
